# Required libraries
library(Matrix)
library(ggplot2)

# Create an output folder for logs
if (!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)

# Capture base R session info
si <- sessionInfo()
saveRDS(si, file = "outputs/sessionInfo.rds")
capture.output(print(si), file = "outputs/sessionInfo.txt")

# ============================================================
# PARAMETERS (organized)
# ============================================================

# =========================
# 1) Simulation setup
# =========================
dt      <- 0.1    # ms, time step
t_sim   <- 1000   # ms, total duration
time    <- seq(0, t_sim, dt)
n_steps <- length(time)

# Optional axonal delays
axonal_delay_inter_ms <- 1.0
axonal_delay_inhib_ms <- 1.2

# =========================
# 2) Populations
# =========================
n_sensory       <- 100  # sensory neurons
n_interneuron   <- 150  # interneurons (spinal processing)
n_motor         <- 50  # motor neurons
n_inter_layers  <- 3   # serial interneuron layers between sensory and motor
n_inhib         <- 100  # inhibitory neurons

# =========================
# 3) Neuron parameter templates
# =========================

# ---- Helper(s)
# Convert current-based weight (nA) to conductance peak (µS) for ΔV ≈ 65 mV
g_from_w <- function(w_nA, deltaV_mV = 65) w_nA / deltaV_mV

# ---- Two-compartment defaults
two_comp_defaults <- list(
  g_c=0.05, C_s=0.15, C_d=0.05, gL_s=0.008, gL_d=0.006,
  use_dend_nl=TRUE, g_nl_max=0.04, V_half_nl=-50, k_nl=6, tau_nl=8.0,
  use_dyn_th=TRUE, V_th0=-55, th_slope=2.0, th_tau=5.0
)

# ---- Base LIF params
lif_params <- list(
  C_m=0.2, g_L=0.01, E_L=-67, V_th=-55, V_reset=-67, tau_ref=2.0,
  tau_syn=5.0, w_syn=0.08, delay_syn=0.75, E_exc=0, E_inh=-72,
  use_noise=TRUE, noise_model="OU", sigma_I_white=0.1, sigma_I_ou=0.15,
  tau_I_ou=5.0, use_channel_noise=TRUE, sigma_gL_frac=0.05, tau_gL=10.0
)

interneuron_params <- list(
  C_m=0.2, g_L=0.01, E_L=-70, V_th=-55, V_reset=-67, tau_ref=2.0,
  tau_syn=5.0, w_syn=0.08, delay_syn=0.75, E_exc=0, E_inh=-72
)

# ---- Merge defaults 
lif_params         <- modifyList(two_comp_defaults, lif_params)
interneuron_params <- modifyList(two_comp_defaults, interneuron_params)

# ---- Inhibitory cell params (start from interneuron_params)
inh_params <- modifyList(interneuron_params, list(
  # inhibitory synapse kinetics (onto their targets)
  tau_syn_inh = 10.0,  # ms, slower GABA_A-like decay
  w_syn_inh   = 0.10,  # nA-equivalent strength
  delay_inh   = 0.75   # ms, synaptic delay
))

# =========================
# 4) Derived synaptic params (AFTER merges)
# =========================
# Excitatory (alpha kernel peaks at 1)
lif_params$g_syn_exc            <- g_from_w(lif_params$w_syn)
lif_params$tau_syn_exc          <- lif_params$tau_syn
lif_params$delay_exc            <- lif_params$delay_syn

interneuron_params$g_syn_exc    <- g_from_w(interneuron_params$w_syn)
interneuron_params$tau_syn_exc  <- interneuron_params$tau_syn
interneuron_params$delay_exc    <- interneuron_params$delay_syn

# Inhibitory (conductance peak from current weight)
inh_params$g_syn_inh            <- g_from_w(inh_params$w_syn_inh)

# =========================
# 5) Stimulus & connectivity
# =========================
# Tonic cutaneous/nociceptive pulse
stim_params <- list(
  start_time = 100,   # ms
  duration   = 50,    # ms
  intensity  = 20,    # nA
  noise_std  = 0.20   # nA
)

# Dense local microcircuit (probabilities)
connectivity <- list(
  sensory_to_inter = 0.6,
  inter_to_motor   = 0.6,
  inter_to_inter   = 0.6,
  sensory_to_inhib = 0.3,
  inhib_to_motor   = 0.3
)

# ============================================================
# SENSORY STIMULUS GENERATION
# ============================================================

generate_sensory_stimulus <- function(time, stim_params, n_neurons) {
    n_steps <- length(time)
    stimulus <- array(0, dim = c(n_neurons, n_steps))
    
    # Create stimulus window
    stim_start_idx <- which(time >= stim_params$start_time)[1]
    stim_end_idx <- which(time <= stim_params$start_time + stim_params$duration)
    stim_end_idx <- stim_end_idx[length(stim_end_idx)]
    
    for (i in 1:n_neurons) {
        # Add stimulus during stimulus window with spatial pattern
        # Simulate noxious stimulus with varying intensity across sensory field
        spatial_weight <- 0.6 + 0.8 * exp(-((i - n_neurons/2)^2) / (2 * (n_neurons/4)^2))
        stimulus[i, stim_start_idx:stim_end_idx] <- stim_params$intensity * 
            spatial_weight * (0.7 + 0.6 * runif(1))
        
        # Add noise throughout simulation
        stimulus[i, ] <- stimulus[i, ] + rnorm(n_steps, 0, stim_params$noise_std)
    }
    
    return(stimulus)
}

# =========================
# Noise helpers
# =========================

ou_step <- function(x, tau_ms, sigma_ss, dt) {
    if (tau_ms <= 0) return(0)
    x + (-x / tau_ms) * dt + sqrt(2 * (sigma_ss^2) / tau_ms) * sqrt(dt) * rnorm(1)
}
white_I_noise <- function(sigma, dt) {
    if (sigma <= 0) return(0)
    sigma * sqrt(dt) * rnorm(1)
}

# =========================
# Vectorized population helpers
# =========================

# Whole-population inhomogeneous Poisson (returns logical matrix [n_neurons x n_steps])
generate_sensory_spikes_inhom_mat <- function(time, stim_params, n_neurons, dt,
                                              base_rate = 5, gain_hz = 25, max_rate = 300) {
  stim_mat <- generate_sensory_stimulus(time, stim_params, n_neurons)  # [n_neurons x n_steps]
  rate_hz  <- pmin(max_rate, pmax(0, base_rate + gain_hz * stim_mat))
  p        <- 1 - exp(-rate_hz * (dt / 1000))                          # Bernoulli p per sample
  matrix(as.logical(rbinom(length(p), 1, as.vector(p))), nrow = n_neurons)
}

# Convert matrices to your existing list-of-neurons shape
as_neuron_list <- function(V_mat, spikes_mat) {
  lapply(seq_len(nrow(spikes_mat)), function(i) list(V = V_mat[i, ], spikes = spikes_mat[i, ]))
}

# Vectorized LIF for a whole population (conductance-based)
simulate_lif_population_cond <- function(gE, gI = NULL, I_ext = NULL, dt, params) {
  stopifnot(is.matrix(gE))
  n_neurons <- nrow(gE); n_steps <- ncol(gE)
  if (is.null(gI))    gI    <- matrix(0, n_neurons, n_steps)
  if (is.null(I_ext)) I_ext <- matrix(0, n_neurons, n_steps)

  V      <- matrix(NA_real_, n_neurons, n_steps)
  spikes <- matrix(FALSE,    n_neurons, n_steps)
  V[, 1] <- params$E_L

  # refractory as step-counts
  ref_steps <- max(0L, ceiling(params$tau_ref / dt))
  ref_cnt   <- integer(n_neurons)

  # noise states
  I_no   <- numeric(n_neurons)
  gL_fac <- numeric(n_neurons)
  sqrt_dt <- sqrt(dt)

  for (t in 2:n_steps) {
    active <- ref_cnt == 0L

    # channel noise on g_L
    g_L_t <- rep_len(params$g_L, n_neurons)
    if (isTRUE(params$use_noise) && isTRUE(params$use_channel_noise) && params$tau_gL > 0) {
      gL_fac <- gL_fac + (-gL_fac / params$tau_gL) * dt +
        sqrt(2 * (params$sigma_gL_frac^2) / params$tau_gL) * sqrt_dt * rnorm(n_neurons)
      g_L_t  <- params$g_L * pmax(0, 1 + gL_fac)
    }

    # current noise
    I_noise <- numeric(n_neurons)
    if (isTRUE(params$use_noise)) {
      if (identical(params$noise_model, "white")) {
        I_noise <- params$sigma_I_white * sqrt_dt * rnorm(n_neurons)
      } else if (identical(params$noise_model, "OU") && params$tau_I_ou > 0) {
        I_no    <- I_no + (-I_no / params$tau_I_ou) * dt +
          sqrt(2 * (params$sigma_I_ou^2) / params$tau_I_ou) * sqrt_dt * rnorm(n_neurons)
        I_noise <- I_no
      }
    }

    # update only non-refractory
    if (any(active)) {
      a   <- which(active)
      Vm  <- V[a, t - 1]
      I_leak <- g_L_t[a] * (params$E_L - Vm)
      I_exc  <- gE[a, t - 1] * (params$E_exc - Vm)
      I_inh  <- gI[a, t - 1] * (params$E_inh - Vm)
      I_tot  <- I_leak + I_exc + I_inh + I_ext[a, t - 1] + I_noise[a]
      V[a, t] <- Vm + (I_tot / params$C_m) * dt

      fired <- V[a, t] >= params$V_th
      if (any(fired)) {
        idx <- a[fired]
        spikes[idx, t] <- TRUE
        V[idx, t]      <- params$V_reset
        ref_cnt[idx]   <- ref_steps
      }
    }

    # refractory bookkeeping
    ref_cnt[ref_cnt > 0L] <- ref_cnt[ref_cnt > 0L] - 1L
    r <- ref_cnt > 0L
    if (any(r)) V[r, t] <- params$V_reset
    untouched <- !(active | r)
    if (any(untouched)) V[untouched, t] <- V[untouched, t - 1]
  }

  list(V = V, spikes = spikes)
}

# two-compartment population simulator
simulate_2comp_population_cond <- function(gE_soma, gI_soma, gE_dend, gI_dend, I_soma, I_dend, dt, params) {
  # Shapes
  stopifnot(is.matrix(gE_soma) || is.null(gE_soma))
  n_steps <- max(
    if (!is.null(gE_soma)) ncol(gE_soma) else 0,
    if (!is.null(gI_soma)) ncol(gI_soma) else 0,
    if (!is.null(gE_dend)) ncol(gE_dend) else 0,
    if (!is.null(gI_dend)) ncol(gI_dend) else 0,
    if (!is.null(I_soma))  ncol(I_soma)  else 0,
    if (!is.null(I_dend))  ncol(I_dend)  else 0
  )
  n_neurons <- max(
    if (!is.null(gE_soma)) nrow(gE_soma) else 0,
    if (!is.null(gI_soma)) nrow(gI_soma) else 0,
    if (!is.null(gE_dend)) nrow(gE_dend) else 0,
    if (!is.null(gI_dend)) nrow(gI_dend) else 0,
    if (!is.null(I_soma))  nrow(I_soma)  else 0,
    if (!is.null(I_dend))  nrow(I_dend)  else 0
  )
  # Default zeros
  zmat <- matrix(0, n_neurons, n_steps)
  if (is.null(gE_soma)) gE_soma <- zmat
  if (is.null(gI_soma)) gI_soma <- zmat
  if (is.null(gE_dend)) gE_dend <- zmat
  if (is.null(gI_dend)) gI_dend <- zmat
  if (is.null(I_soma))  I_soma  <- zmat
  if (is.null(I_dend))  I_dend  <- zmat

  # State
  Vs <- matrix(params$E_L, n_neurons, n_steps)  # soma
  Vd <- matrix(params$E_L, n_neurons, n_steps)  # dend
  spikes <- matrix(FALSE, n_neurons, n_steps)

  # Dynamic threshold & dendritic nonlinearity
  Vth  <- rep(params$V_th0, n_neurons)
  gnl  <- rep(0.0, n_neurons)

  # Refractory
  ref_steps <- max(0L, ceiling(params$tau_ref / dt))
  ref_cnt   <- integer(n_neurons)

  E_Ls <- params$E_L
  E_Ld <- params$E_L

  for (t in 2:n_steps) {
    active <- ref_cnt == 0L

    # Dendritic nonlinearity
    if (isTRUE(params$use_dend_nl) && params$tau_nl > 0) {
      m_inf <- 1 / (1 + exp(-(Vd[, t-1] - params$V_half_nl) / params$k_nl))
      gnl   <- gnl + (m_inf - gnl) * (dt / params$tau_nl)
    } else gnl[] <- 0
    g_nl_t <- params$g_nl_max * pmax(0, pmin(1, gnl))

    # Currents
    I_leak_s <- params$gL_s * (E_Ls - Vs[, t-1])
    I_leak_d <- params$gL_d * (E_Ld - Vd[, t-1])

    I_syn_s  <- gE_soma[, t-1] * (params$E_exc - Vs[, t-1]) +
                gI_soma[, t-1] * (params$E_inh - Vs[, t-1]) +
                I_soma[,  t-1]

    I_syn_d  <- gE_dend[, t-1] * (params$E_exc - Vd[, t-1]) +
                gI_dend[, t-1] * (params$E_inh - Vd[, t-1]) +
                I_dend[,  t-1]  +
                g_nl_t * (params$E_exc - Vd[, t-1])

    # Coupling
    I_c_s <- params$g_c * (Vd[, t-1] - Vs[, t-1])
    I_c_d <- -I_c_s

    # Update active
    if (any(active)) {
      a <- which(active)
      dVs <- (I_leak_s[a] + I_syn_s[a] + I_c_s[a]) / params$C_s
      dVd <- (I_leak_d[a] + I_syn_d[a] + I_c_d[a]) / params$C_d
      Vs[a, t] <- Vs[a, t-1] + dVs * dt
      Vd[a, t] <- Vd[a, t-1] + dVd * dt

      # Dynamic threshold at soma
      if (isTRUE(params$use_dyn_th) && params$th_tau > 0) {
        dVdt <- dVs
        Vth[a] <- Vth[a] + (params$V_th0 - Vth[a]) * (dt / params$th_tau) +
                  params$th_slope * dVdt * dt
      } else Vth[a] <- params$V_th0

      fired <- Vs[a, t] >= Vth[a]
      if (any(fired)) {
        idx <- a[fired]
        spikes[idx, t] <- TRUE
        Vs[idx, t]     <- params$V_reset
        Vd[idx, t]     <- Vd[idx, t] - 5   # mild back-prop dip (optional)
        ref_cnt[idx]   <- ref_steps
      }
    }

    # Refractory handling
    ref_cnt[ref_cnt > 0L] <- ref_cnt[ref_cnt > 0L] - 1L
    r <- ref_cnt > 0L
    if (any(r)) {
      Vs[r, t] <- params$V_reset
      Vd[r, t] <- Vd[r, t-1] + ((params$gL_d * (E_Ld - Vd[r, t-1])) / params$C_d) * dt
    }

    stay <- !(active | r)
    if (any(stay)) {
      Vs[stay, t] <- Vs[stay, t-1]
      Vd[stay, t] <- Vd[stay, t-1]
    }
  }

  list(Vs = Vs, Vd = Vd, spikes = spikes)
}


# ============================================================
# LIF NEURON MODEL (Conductance-based synapses)
# ============================================================
simulate_lif_neuron_cond <- function(inputs, dt, params) {
    gE <- if (!is.null(inputs$gE)) inputs$gE else rep(0, length(inputs$I_ext))
    gI <- if (!is.null(inputs$gI)) inputs$gI else rep(0, length(gE))
    I_ext <- if (!is.null(inputs$I_ext)) inputs$I_ext else rep(0, length(gE))
    
    n_steps <- max(length(gE), length(gI), length(I_ext))
    V <- numeric(n_steps); spikes <- logical(n_steps)
    V[1] <- params$E_L; t_last_spike <- -Inf
    I_no <- 0; gL_fac <- 0
    
    for (t in 2:n_steps) {
        current_time <- (t - 1) * dt
        if (current_time - t_last_spike > params$tau_ref) {
            
            # leak/channel noise on g_L
            g_L_t <- params$g_L
            if (isTRUE(params$use_noise) && isTRUE(params$use_channel_noise)) {
                gL_fac <- ou_step(gL_fac, params$tau_gL, params$sigma_gL_frac, dt)
                g_L_t  <- params$g_L * pmax(0, 1 + gL_fac)
            }
            
            # membrane current noise (still current-based noise) 
            I_noise <- 0
            if (isTRUE(params$use_noise)) {
                if (identical(params$noise_model, "white")) {
                    I_noise <- white_I_noise(params$sigma_I_white, dt)
                } else if (identical(params$noise_model, "OU")) {
                    I_no    <- ou_step(I_no, params$tau_I_ou, params$sigma_I_ou, dt)
                    I_noise <- I_no
                }
            }
            
            # conductance-based synaptic currents (nA) 
            I_leak <- g_L_t * (params$E_L - V[t-1])
            I_exc  <- gE[t-1] * (params$E_exc - V[t-1])
            I_inh  <- gI[t-1] * (params$E_inh - V[t-1])
            
            I_tot  <- I_leak + I_exc + I_inh + I_ext[t-1] + I_noise
            dV_dt  <- I_tot / params$C_m           # C in nF, currents in nA â†’ mV/ms
            V[t]   <- V[t-1] + dV_dt * dt
            
            if (V[t] >= params$V_th) {
                spikes[t] <- TRUE; V[t] <- params$V_reset; t_last_spike <- current_time
            }
        } else {
            V[t] <- params$V_reset
        }
    }
    list(V = V, spikes = spikes)
}

# ============================================================
# CONDUCTANCE-BASED SYNAPTIC TRANSMISSION
# ============================================================
# Fast alpha-kernel synapses via convolution 
build_alpha_kernel <- function(tau_ms, g_peak, delay_ms, dt, n_tau = 5) {
    klen <- max(1L, ceiling(n_tau * tau_ms / dt))
    tvec <- (0:klen) * dt
    alpha <- (tvec / tau_ms) * exp(1 - tvec / tau_ms)   # peaks at 1
    delay_steps <- max(0L, round(delay_ms / dt))
    c(rep(0, delay_steps), g_peak * alpha)              # include synaptic delay
}

# Convolve 1 spike train (logical/0-1) with kernel; truncate to n_steps
# --- drop-in replacement ---
# --- drop-in: fast true convolution for alpha synapses ---
syn_alpha_from_spikes <- function(S, g_peak, tau_ms, delay_ms, dt,
                                  engine = c("stats", "signal")) {
  engine <- match.arg(engine)
  stopifnot(is.matrix(S))
  n_pre   <- nrow(S)
  n_steps <- ncol(S)

  # Causal kernel already includes synaptic delay
  K <- build_alpha_kernel(tau_ms   = tau_ms,
                          g_peak   = g_peak,
                          delay_ms = delay_ms,
                          dt       = dt)
  L <- length(K)

  # pad-left for causal FIR convolution
  pad_and_convolve <- function(x) {
    xpad <- c(rep(0, L - 1), as.numeric(x))
    if (engine == "stats") {
      y <- stats::filter(xpad, filter = K, method = "convolution", sides = 1)
      y <- as.numeric(y)
    } else {
      # requires: library(signal)
      y <- as.numeric(signal::filter(b = K, a = 1, x = xpad))
    }
    # causal alignment: drop padding and keep first n_steps
    y[L:(L + n_steps - 1)]
  }

  # row-wise convolution (one per presynaptic neuron)
  G <- t(apply(S, 1, pad_and_convolve))
  dimnames(G) <- NULL
  G
}

# helpers to route synapses to dendrite vs soma
# Exponential dendritic low-pass to mimic distal filtering
build_dend_filter <- function(tau_ms = 3, att = 0.7, dt = 0.1, n_tau = 6) {
  L <- max(1L, ceiling(n_tau * tau_ms / dt))
  t <- (0:(L-1)) * dt
  k <- exp(-t / tau_ms)
  att * k / sum(k)  # normalized area, attenuated
}

# Split a gE/gI matrix into (soma, dend) parts + optional dendritic filtering
split_syn_by_location <- function(g_mat, p_to_dend = 0.8, dend_k = NULL) {
  if (is.null(g_mat)) return(list(soma = NULL, dend = NULL))
  soma <- (1 - p_to_dend) * g_mat
  dend <- p_to_dend       * g_mat
  if (!is.null(dend_k)) {
    L <- length(dend_k)
    filt_row <- function(x) {
      xp <- c(rep(0, L-1), x)
      y  <- stats::filter(xp, dend_k, method = "convolution", sides = 1)
      as.numeric(y[L:(L + length(x) - 1)])
    }
    dend <- t(apply(dend, 1, filt_row))
  }
  list(soma = soma, dend = dend)
}



# ============================================================
# POLYSYNAPTIC NETWORK SIMULATION
# ============================================================

simulate_polysynaptic_reflex <- function() {
  cat("Generating sensory stimulus...\n")

  # ---- Sensory spikes (vectorized) ----
  cat("Simulating sensory neurons (inhomogeneous Poisson)â€¦\n")
  sens_spk <- generate_sensory_spikes_inhom_mat(time, stim_params, n_sensory, dt)
  sensory_neurons <- as_neuron_list(
    V_mat      = matrix(lif_params$E_L, n_sensory, n_steps),
    spikes_mat = sens_spk
  )

  # ---- Precompute kernels ----
  K_SI <- build_alpha_kernel(
    tau_ms   = lif_params$tau_syn_exc,
    g_peak   = lif_params$g_syn_exc,
    delay_ms = lif_params$delay_exc,
    dt       = dt
  )
  K_II <- build_alpha_kernel(
    tau_ms   = interneuron_params$tau_syn_exc,
    g_peak   = interneuron_params$g_syn_exc,
    delay_ms = interneuron_params$delay_exc + axonal_delay_inter_ms,
    dt       = dt
  )
  K_IM <- K_II

  # ---- Connectivity ----
  W_SI <- Matrix::rsparsematrix(n_interneuron, n_sensory, density = connectivity$sensory_to_inter)
  if (length(W_SI@x)) W_SI@x <- runif(length(W_SI@x), 0.7, 1.3)

  W_II_list <- vector("list", max(0, n_inter_layers - 1L))
  for (L in seq_along(W_II_list)) {
    W_II_list[[L]] <- Matrix::rsparsematrix(n_interneuron, n_interneuron, density = connectivity$inter_to_inter)
    if (length(W_II_list[[L]]@x)) W_II_list[[L]]@x <- runif(length(W_II_list[[L]]@x), 0.7, 1.3)
  }

  W_IM <- Matrix::rsparsematrix(n_motor, n_interneuron, density = connectivity$inter_to_motor)
  if (length(W_IM@x)) W_IM@x <- runif(length(W_IM@x), 0.7, 1.3)


  # ---- S -> Inter layer 1 (vectorized) ----
 G_S <- syn_alpha_from_spikes(
  sens_spk,
  lif_params$g_syn_exc, lif_params$tau_syn_exc,
  delay_ms = lif_params$delay_exc,   # keep sensory synaptic delay here
  dt = dt
)

# ---- Build inhibitory population (feedforward) ----
# sensory -> inhibitory (excitatory drive)
W_SInh <- Matrix::rsparsematrix(n_inhib, n_sensory, density = connectivity$sensory_to_inhib)
if (length(W_SInh@x)) W_SInh@x <- runif(length(W_SInh@x), 0.7, 1.3)

G_S_for_inh <- syn_alpha_from_spikes(
  sens_spk,
  lif_params$g_syn_exc, lif_params$tau_syn_exc,
  delay_ms = lif_params$delay_exc,  # excitatory drive onto inhibitory cells
  dt = dt
)

inh_gE <- as.matrix(W_SInh %*% G_S_for_inh)

# split to soma/dend with same helper
dend_kern <- build_dend_filter(tau_ms = 2.5, att = 0.8, dt = dt) 
spl_inh <- split_syn_by_location(inh_gE, p_to_dend = 0.85, dend_k = dend_kern)

# simulate inhibitory cells (they spike using excitatory input)
simInh <- simulate_2comp_population_cond(
  gE_soma = spl_inh$soma, gI_soma = NULL,
  gE_dend = spl_inh$dend, gI_dend = NULL,
  I_soma  = NULL,         I_dend  = NULL,
  dt = dt, params = inh_params
)
inh_spikes <- simInh$spikes

  inter_gE <- as.matrix(W_SI %*% G_S)
spl <- split_syn_by_location(inter_gE, p_to_dend = 0.85, dend_k = dend_kern)
simL1 <- simulate_2comp_population_cond(
  gE_soma = spl$soma, gI_soma = NULL,
  gE_dend = spl$dend, gI_dend = NULL,
  I_soma  = NULL,     I_dend  = NULL,
  dt = dt, params = interneuron_params
)
inter_layers_inputs <- vector("list", n_inter_layers)
inter_layers_inputs[[1]] <- inter_gE
inter_layers <- vector("list", n_inter_layers)
inter_layers[[1]] <- lapply(seq_len(n_interneuron), function(i) list(
  V  = simL1$Vs[i,],      # SOMA voltage (keeps downstream code unchanged)
  Vd = simL1$Vd[i,],      # optional: dendrite for plotting
  spikes = simL1$spikes[i,]
))
prev_spikes <- simL1$spikes


  # ---- Serial Inter -> Inter (vectorized per layer) ----
 if (n_inter_layers >= 2) {
  for (L in 2:n_inter_layers) {
    G_prev <- syn_alpha_from_spikes(
      prev_spikes,
      interneuron_params$g_syn_exc, interneuron_params$tau_syn_exc,
      delay_ms = interneuron_params$delay_exc + axonal_delay_inter_ms,  # <-- add axonal delay
      dt = dt
    )
inter_gE <- as.matrix(W_II_list[[L - 1]] %*% G_prev)
inter_layers_inputs[[L]] <- inter_gE

spl <- split_syn_by_location(inter_gE, p_to_dend = 0.85, dend_k = dend_kern)
simL <- simulate_2comp_population_cond(
  gE_soma = spl$soma, gI_soma = NULL,
  gE_dend = spl$dend, gI_dend = NULL,
  I_soma  = NULL,     I_dend  = NULL,
  dt = dt, params = interneuron_params
)
inter_layers[[L]] <- lapply(seq_len(n_interneuron), function(i) list(
  V  = simL$Vs[i,],
  Vd = simL$Vd[i,],
  spikes = simL$spikes[i,]
))
prev_spikes <- simL$spikes

  }
}

  G_last <- syn_alpha_from_spikes(
  prev_spikes,
  interneuron_params$g_syn_exc, interneuron_params$tau_syn_exc,
  delay_ms = interneuron_params$delay_exc + axonal_delay_inter_ms,      # <-- add axonal delay
  dt = dt
)
motor_gE_input <- as.matrix(W_IM %*% G_last)
splM <- split_syn_by_location(motor_gE_input, p_to_dend = 0.9, dend_k = dend_kern)
# inhibitory -> motor (produce gI onto motor)
W_IM_inh <- Matrix::rsparsematrix(n_motor, n_inhib, density = connectivity$inhib_to_motor)
if (length(W_IM_inh@x)) W_IM_inh@x <- runif(length(W_IM_inh@x), 0.7, 1.3)

G_I_to_M <- syn_alpha_from_spikes(
  inh_spikes,
  inh_params$g_syn_inh, inh_params$tau_syn_inh,
  delay_ms = inh_params$delay_inh + axonal_delay_inhib_ms,
  dt = dt
)

motor_gI_input <- as.matrix(W_IM_inh %*% G_I_to_M)

# split inhibitory conductance by location
splM_I <- split_syn_by_location(motor_gI_input, p_to_dend = 0.6, dend_k = dend_kern)  # typically more somatic


motor_sim <- simulate_2comp_population_cond(
  gE_soma = splM$soma, gI_soma = splM_I$soma,   
  gE_dend = splM$dend, gI_dend = splM_I$dend,
  I_soma  = NULL,      I_dend  = NULL,
  dt = dt, params = lif_params
)
motor_neurons <- lapply(seq_len(n_motor), function(i) list(
  V  = motor_sim$Vs[i,],     # SOMA voltage
  Vd = motor_sim$Vd[i,],     # optional: dendrite
  spikes = motor_sim$spikes[i,]
))

  list(
    sensory              = sensory_neurons,        # same external shape
    interneurons_layers  = inter_layers,           # same external shape
    sensory_stimulus     = generate_sensory_stimulus(time, stim_params, n_sensory),
    inter_inputs         = inter_layers_inputs,    # gE traces (ÂµS)
    motor                = motor_neurons,          # same external shape
    motor_input          = motor_gE_input,         # gE traces (ÂµS)
    time                 = time
  )
}

# ============================================================
# MOTOR ACTION QUANTIFICATION
# ============================================================

calculate_motor_response <- function(motor_neurons, time) {
    motor_activity <- numeric(length(time))
    
    for (j in 1:length(motor_neurons)) {
        spike_train <- motor_neurons[[j]]$spikes
        motor_activity <- motor_activity + as.numeric(spike_train)
    }
    
# Smooth motor activity (representing muscle activation)
motor_response <- as.numeric(stats::filter(motor_activity, rep(1/7, 7), sides = 2))
motor_response[is.na(motor_response)] <- 0
    return(motor_response)
}

# ============================================================
# LATENCY CALCULATION
# ============================================================

calculate_reflex_latency <- function(stimulus_time, motor_response, time) {
    # Use the passed-in stimulus_time (don’t read the global)
    stim_onset <- stimulus_time
    
    # Find first significant motor response (threshold crossing)
    baseline  <- mean(motor_response[time < stim_onset])
    threshold <- baseline + 2.5 * sd(motor_response[time < stim_onset])
    
    response_idx <- which(motor_response > threshold & time > stim_onset)[1]
    if (is.na(response_idx)) return(NA_real_)
    
    time[response_idx] - stim_onset
}


# ============================================================
# BIAS CORRECTION
# ============================================================

# KSG kNN MI with shuffle-baseline bias correction (bits)
knn_mi_ksg <- function(x, y, k = 5L, jitter = 1e-8) {
    stopifnot(length(x) == length(y))
    n <- length(x); if (n <= k + 1L) return(NA_real_)
    x <- as.numeric(x); y <- as.numeric(y)
    if (jitter > 0) {
        x <- x + rnorm(n, 0, max(1e-12, sd(x) * jitter))
        y <- y + rnorm(n, 0, max(1e-12, sd(y) * jitter))
    }
    Dx <- abs(outer(x, x, "-")); Dy <- abs(outer(y, y, "-"))
    D  <- pmax(Dx, Dy); diag(D) <- Inf
    eps <- apply(D, 1, function(row) sort(row, partial = k)[k])
    diag(Dx) <- Inf; diag(Dy) <- Inf
    nx <- vapply(seq_len(n), function(i) sum(Dx[i,] < eps[i]), integer(1))
    ny <- vapply(seq_len(n), function(i) sum(Dy[i,] < eps[i]), integer(1))
    I_nats <- digamma(k) + digamma(n) - mean(digamma(nx + 1L) + digamma(ny + 1L))
    max(0, I_nats / log(2))
}

mi_knn_bias_corrected <- function(x, y, k = 5L, n_shuffles = 100L, jitter = 1e-8) {
    mi_raw <- knn_mi_ksg(x, y, k, jitter)   # <-- was mi_knn_ksg_bits
    if (!is.finite(mi_raw) || n_shuffles <= 0L)
        return(list(mi_knn = mi_raw, mi_knn_bc = mi_raw, mi_shuffle_mean = 0))
    mi_shuf <- replicate(n_shuffles, knn_mi_ksg(x, sample(y), k, jitter))
    mu <- mean(mi_shuf[is.finite(mi_shuf)], na.rm = TRUE)
    list(mi_knn = mi_raw, mi_knn_bc = max(0, mi_raw - mu), mi_shuffle_mean = mu)
}

# ============================================================
# INFORMATION CALCULATION
# ============================================================
# MI of Sensoryâ†’Motor ONLY (no interneurons used) 
calculate_information_metrics <- function(results,
                                          bin_ms = 5,
                                          k = 3L,
                                          n_shuffles = 100L,
                                          max_lag_ms = 60,
                                          pre_ms = 20,
                                          post_ms = 600) {
    cat("Calculating information metrics (Sâ†’M only)â€¦\n")
    
    # Population spike sums
    sensory_pop <- rowSums(sapply(results$sensory, function(x) as.numeric(x$spikes)))
    motor_pop   <- rowSums(sapply(results$motor,   function(x) as.numeric(x$spikes)))
    
    # Basic rates & totals (for summary/prints)
    t_s <- t_sim / 1000
    sensory_rates <- sapply(results$sensory, function(x) sum(x$spikes)) / t_s
    motor_rates   <- sapply(results$motor,   function(x) sum(x$spikes)) / t_s
    total_sensory_spikes <- sum(sensory_pop)
    total_motor_spikes   <- sum(motor_pop)
    
    # Window around stimulus
    win <- results$time >= (stim_params$start_time - pre_ms) &
        results$time <= (stim_params$start_time + post_ms)
    s <- sensory_pop[win]; m <- motor_pop[win]
    
    # Binning
    bin_size <- max(1L, ceiling(bin_ms / dt))
    n_bins_win <- floor(length(s) / bin_size)
    if (n_bins_win < (k + 2L)) {
        warning("Not enough bins for kNN MI; reduce bin_ms, enlarge window, or lower k.")
        return(list(
            sensory_rates = sensory_rates,
            motor_rates   = motor_rates,
            inter_rates   = NA_real_,
            sensory_motor_mi = NA_real_,
            total_pathway_mi = NA_real_,
            n_bins = n_bins_win,
            lags_bins = list(SM = 0L),
            lags_ms   = list(SM = 0),
            sensory_binned = integer(0),
            motor_binned   = integer(0),
            total_sensory_spikes = total_sensory_spikes,
            total_inter_spikes   = NA_integer_,
            total_motor_spikes   = total_motor_spikes
        ))
    }
    
    rng <- seq_len(n_bins_win * bin_size)
    sb <- colSums(matrix(s[rng], nrow = bin_size))
    mb <- colSums(matrix(m[rng], nrow = bin_size))
    
    # Align by measured reflex latency
    motor_response_full <- calculate_motor_response(results$motor, results$time)
    latency_ms <- calculate_reflex_latency(stim_params$start_time, motor_response_full, results$time)
    lag_bins_sm <- if (is.na(latency_ms)) 0L else as.integer(round(latency_ms / bin_ms))
    
    align_pair <- function(x, y, L) {
        if (L > 0) {
            n <- min(length(x), length(y) - L); if (n <= 0) return(list(x = numeric(0), y = numeric(0)))
            list(x = x[seq_len(n)], y = y[(1 + L):(L + n)])
        } else if (L < 0) {
            L <- -L; n <- min(length(x) - L, length(y)); if (n <= 0) return(list(x = numeric(0), y = numeric(0)))
            list(x = x[(1 + L):(L + n)], y = y[seq_len(n)])
        } else list(x = x, y = y)
    }
    ab_sm <- align_pair(sb, mb, lag_bins_sm)
    ok_sm <- length(ab_sm$x) > (k + 1L)
    
    mi_sm <- if (ok_sm) mi_knn_bias_corrected(ab_sm$x, ab_sm$y, k = k, n_shuffles = n_shuffles)$mi_knn_bc else NA_real_
    
    list(
        sensory_rates = sensory_rates,
        inter_rates   = NA_real_,
        motor_rates   = motor_rates,
        sensory_motor_mi = mi_sm,     # <-- the MI you care about
        total_pathway_mi = mi_sm,     # <-- make "total" equal to Sâ†’M
        n_bins = length(ab_sm$x),
        lags_bins = list(SM = lag_bins_sm),
        lags_ms   = list(SM = lag_bins_sm * bin_ms),
        sensory_binned = sb,
        motor_binned   = mb,
        total_sensory_spikes = total_sensory_spikes,
        total_inter_spikes   = NA_integer_,
        total_motor_spikes   = total_motor_spikes
    )
}

mi_vs_lag <- function(sim, bin_ms = 10, lags_ms = seq(-80, 120, by = 10), k = 5, n_shuffles = 100) {
    s_pop <- rowSums(sapply(sim$sensory, function(x) as.integer(x$spikes)))
    m_pop <- rowSums(sapply(sim$motor,   function(x) as.integer(x$spikes)))
    
    bin_size <- max(1L, ceiling(bin_ms / dt))
    to_bins <- function(v) {
        nb <- floor(length(v) / bin_size)
        if (nb < 1) return(integer(0))
        rng <- seq_len(nb * bin_size)
        colSums(matrix(v[rng], nrow = bin_size))
    }
    sb <- to_bins(s_pop); mb <- to_bins(m_pop)
    if (length(sb) < (k + 2L) || length(mb) < (k + 2L))
        stop("Not enough binsâ€”increase t_sim or reduce bin_ms.")
    
    lag_bins <- round(lags_ms / bin_ms)
    est <- function(L) {
        if (L > 0) {
            n <- min(length(sb), length(mb) - L); if (n <= 0) return(NA_real_)
            mi_knn_bias_corrected(sb[seq_len(n)], mb[(1+L):(L+n)], k = k, n_shuffles = n_shuffles)$mi_knn_bc
        } else if (L < 0) {
            L <- -L; n <- min(length(sb) - L, length(mb)); if (n <= 0) return(NA_real_)
            mi_knn_bias_corrected(sb[(1+L):(L+n)], mb[seq_len(n)], k = k, n_shuffles = n_shuffles)$mi_knn_bc
        } else {
            mi_knn_bias_corrected(sb, mb, k = k, n_shuffles = n_shuffles)$mi_knn_bc
        }
    }
    mi <- vapply(lag_bins, est, numeric(1))
    data.frame(lag_ms = lags_ms, mi_bits = mi, mi_rate = mi * (1000/bin_ms))
}

plot_mi_vs_lag <- function(tbl) {
    ggplot(tbl, aes(lag_ms, mi_bits)) +
        geom_line() + geom_point(size = 1) +
        labs(x = "Lag (ms)", y = "MI (bits/bin)", title = "Sensory â†’ Motor MI vs lag") +
        theme_bw()
}


# ================================================================
# Information per bin
# ================================================================
# Bin a single neuron's spike train (logical) into counts per bin
bin_spike_train <- function(spikes_logical, bin_size) {
    n <- length(spikes_logical)
    n_bins <- floor(n / bin_size)
    if (n_bins < 1) return(integer(0))
    rng <- seq_len(n_bins * bin_size)
    colSums(matrix(as.integer(spikes_logical[rng]), nrow = bin_size))
}

# Build a (neurons x bins) matrix of counts for a population
binned_counts_matrix <- function(neuron_list, bin_size) {
    stopifnot(length(neuron_list) > 0)
    one <- bin_spike_train(neuron_list[[1]]$spikes, bin_size)
    if (length(one) == 0) return(matrix(integer(0), nrow = length(neuron_list), ncol = 0))
    out <- matrix(0L, nrow = length(neuron_list), ncol = length(one))
    for (i in seq_along(neuron_list)) {
        out[i, ] <- bin_spike_train(neuron_list[[i]]$spikes, bin_size)
    }
    out
}

# ===========================================================
# Pairwise
# ===========================================================
# Compute pairwise KSG MI between every sensory and motor neuron
# lag_bins: shift motor counts forward (positive) or backward (negative) in bins
knn_mi_pairwise_sensory_motor <- function(results, bin_ms = 15, k = 5, lag_bins = 0) {
    bin_size <- max(1L, ceiling(bin_ms / dt))
    
    S <- binned_counts_matrix(results$sensory, bin_size)  # (n_sensory x n_bins)
    M <- binned_counts_matrix(results$motor,    bin_size)  # (n_motor   x n_bins)
    
    if (ncol(S) == 0L || ncol(M) == 0L) {
        warning("Not enough bins for kNN MI; increase t_sim or reduce bin_ms.")
        return(list(MI = matrix(NA_real_, nrow = nrow(S), ncol = nrow(M)),
                    bin_size = bin_size, n_bins = 0L))
    }
    
    # Apply optional lag to motor (aligning with reflex latency in bins)
    align_pair <- function(a, b, lag) {
        if (lag == 0) return(list(ax = a, bx = b))
        if (lag > 0) {
            # motor lagging; drop first 'lag' bins of motor and last 'lag' of sensory
            n <- min(length(a), length(b) - lag)
            if (n <= 0) return(list(ax = numeric(0), bx = numeric(0)))
            list(ax = a[seq_len(n)], bx = b[seq(lag + 1, length.out = n)])
        } else {
            # motor leading; drop first '-lag' bins of sensory and last '-lag' of motor
            lag <- -lag
            n <- min(length(a) - lag, length(b))
            if (n <= 0) return(list(ax = numeric(0), bx = numeric(0)))
            list(ax = a[seq(lag + 1, length.out = n)], bx = b[seq_len(n)])
        }
    }
    
    ns <- nrow(S); nm <- nrow(M)
    MI <- matrix(NA_real_, nrow = ns, ncol = nm)
    for (i in seq_len(ns)) {
        for (j in seq_len(nm)) {
            ab <- align_pair(S[i, ], M[j, ], lag_bins)
            if (length(ab$ax) > k && length(ab$bx) > k) {
                MI[i, j] <- knn_mi_ksg(ab$ax, ab$bx, k = k)
            } else {
                MI[i, j] <- NA_real_
            }
        }
    }
    
    rownames(MI) <- paste0("S", seq_len(ns))
    colnames(MI) <- paste0("M", seq_len(nm))
    list(MI = MI, bin_size = bin_size, n_bins = ncol(S))
}

# ============================================================
# Multi Trials
# ============================================================

# MULTI-TRIAL HELPER
run_mi_over_trials <- function(n_trials = 30, bin_ms = 5, k = 3, pre_ms = 20, post_ms = 600) {
    sb_all <- integer(0); mb_all <- integer(0)
    for (r in seq_len(n_trials)) {
        set.seed(1000 + r)
        res <- simulate_polysynaptic_reflex()
        win <- res$time >= (stim_params$start_time - pre_ms) &
            res$time <= (stim_params$start_time + post_ms)
        s <- rowSums(sapply(res$sensory, function(x) as.integer(x$spikes)))[win]
        m <- rowSums(sapply(res$motor,   function(x) as.integer(x$spikes)))[win]
        bin_size <- max(1L, ceiling(bin_ms / dt))
        rng <- seq_len(floor(length(s) / bin_size) * bin_size)
        sb <- colSums(matrix(s[rng], nrow = bin_size))
        mb <- colSums(matrix(m[rng], nrow = bin_size))
        sb_all <- c(sb_all, sb); mb_all <- c(mb_all, mb)
    }
    mi_knn_bias_corrected(sb_all, mb_all, k = k, n_shuffles = 50L)
}


# ============================================================
# PROCESSING SPEED CALCULATION
# ============================================================

calculate_processing_speed <- function(latency_ms, total_mi, n_bins) {
    if (is.na(latency_ms) || latency_ms <= 0 ||
        is.na(total_mi) || is.na(n_bins) || n_bins <= 0) return(NA_real_)
    
    # Total information transferred through the pathway
    total_info_bits <- total_mi * n_bins
    
    # Processing speed in bits per second
    processing_speed <- total_info_bits / (latency_ms / 1000)
    
    return(processing_speed)
}

# ============================================================
# MAIN SIMULATION FUNCTION
# ============================================================

run_polysynaptic_reflex_simulation <- function() {
    cat("Starting polysynaptic reflex simulation...\n")
    cat("Parameters:\n")
    cat(sprintf("  - Sensory neurons: %d\n", n_sensory))
    cat(sprintf("  - Interneurons: %d\n", n_interneuron))
    cat(sprintf("  - Motor neurons: %d\n", n_motor))
    cat(sprintf("  - Simulation time: %d ms\n", t_sim))
    cat(sprintf("  - Time step: %.1f ms\n", dt))
    
    # Run network simulation
    results <- simulate_polysynaptic_reflex()
    lag_tbl <- mi_vs_lag(results, bin_ms = 10, k = 5, n_shuffles = 100)
    
    # Calculate motor response
    motor_response <- calculate_motor_response(results$motor, results$time)
    
    # Calculate latency
    latency <- calculate_reflex_latency(stim_params$start_time, motor_response, results$time)
    
    # Calculate information metrics
    info_metrics <- calculate_information_metrics(results)
    
    # Calculate processing speed
    processing_speed <- calculate_processing_speed(
        latency_ms = latency,
        total_mi = info_metrics$total_pathway_mi,
        n_bins = info_metrics$n_bins
    )
    
    # Print results
    cat("\n", paste(rep("=", 60), collapse = ""), "\n")
    cat("REFLEX SIMULATION RESULTS (Sâ†’M MI)\n")
    cat(paste(rep("=", 60), collapse = ""), "\n")
    cat(sprintf("Reflex Latency: %s\n",
            if (is.na(latency)) "NA" else sprintf("%.2f ms", latency)))
    cat(sprintf("Sensoryâ†’Motor MI (KSG, bias-corrected): %.4f bits\n", info_metrics$sensory_motor_mi))
    cat(sprintf("Total Pathway MI (Sâ†’M): %.4f bits\n", info_metrics$total_pathway_mi))
    cat(sprintf("Processing Speed: %.2f bits/second\n", processing_speed))
    cat(sprintf("Total Sensory Spikes: %d\n", info_metrics$total_sensory_spikes))
    cat(sprintf("Total Motor Spikes: %d\n", info_metrics$total_motor_spikes))
    cat(sprintf("Mean Sensory Rate: %.2f Hz\n", mean(info_metrics$sensory_rates)))
    cat(sprintf("Mean Motor Rate: %.2f Hz\n", mean(info_metrics$motor_rates)))
    
    return(list(
        results = results,
        latency = latency,
        processing_speed = processing_speed,
        info_metrics = info_metrics,
        motor_response = motor_response,
        lag_tbl = lag_tbl
    ))
}

# ============================================================
# HELPER FOR LOGS
#=============================================================
write_session_info <- function(outdir = "outputs") {
  if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)
  si <- sessionInfo()
  saveRDS(si, file.path(outdir, "sessionInfo.rds"))
  capture.output(print(si), file = file.path(outdir, "sessionInfo.txt"))
}

# ============================================================
# MULTI-TRIAL RUNNER WITH AGGREGATES (monosynaptic-style output)
# ============================================================
run_experiment <- function(n_trials = 10,
                           n_shuffles = 100,
                           bin_ms = 10,
                           verbose = TRUE,
                           seed = NULL) {
  on.exit(write_session_info("outputs"), add = TRUE)
  if (!is.null(seed)) set.seed(seed)

  # collectors (one value per trial)
  latencies  <- numeric(n_trials)
  mi_bin_bc  <- numeric(n_trials)
  mi_rate_bc <- numeric(n_trials)
  speeds_bc  <- numeric(n_trials)

  for (r in seq_len(n_trials)) {
    if (verbose) cat(sprintf("\n--- Trial %d/%d ---\n", r, n_trials))

    # run one polysynaptic simulation (quietly if desired)
    sim <- simulate_polysynaptic_reflex()

    # latency (ms)
    motor_resp <- calculate_motor_response(sim$motor, sim$time)
    lat <- calculate_reflex_latency(stim_params$start_time, motor_resp, sim$time)

    # information (bits/bin) + bins
    info <- calculate_information_metrics(
      sim,
      bin_ms     = bin_ms,
      n_shuffles = n_shuffles
      # (pass k, pre_ms, post_ms here if you want to tweak them)
    )

    # per-bin MI (bias-corrected) & MI rate (bits/s)
    mi_bin <- info$total_pathway_mi                 # == sensory_motor_mi
    mi_rt  <- mi_bin * (1000 / bin_ms)

    # processing speed (bits/s) using your helper
    spd <- calculate_processing_speed(
      latency_ms = lat,
      total_mi   = mi_bin,
      n_bins     = info$n_bins
    )

    latencies[r]  <- lat
    mi_bin_bc[r]  <- mi_bin
    mi_rate_bc[r] <- mi_rt
    speeds_bc[r]  <- spd
  }

  # summary helper (matches monosynaptic)
  summ <- function(x) {
    x <- x[is.finite(x)]
    m <- mean(x); s <- sd(x)
    n <- length(x); se <- s / sqrt(max(1, n))
    ci95 <- c(max(0, m - 1.96 * se), m + 1.96 * se)
    list(mean = m, sd = s, n = n, ci95 = ci95)
  }

  summary <- list(
    latency_ms                        = summ(latencies),
    mi_per_bin_BC                     = summ(mi_bin_bc),
    mi_rate_BC_bits_per_s             = summ(mi_rate_bc),
    processing_speed_BC_bits_per_s    = summ(speeds_bc)
  )

  # Pretty print â€” identical format to the monosynaptic script
  cat("\n", paste(rep("=", 60), collapse = ""), "\n")
  cat("MULTI-TRIAL SUMMARY (bias-corrected MI)\n")
  cat(paste(rep("=", 60), collapse = ""), "\n")
  prn <- function(name, s, unit="") {
    cat(sprintf("%-28s mean = %.3f%s | sd = %.3f | n = %d | 95%% CI [%.3f, %.3f]\n",
                name, s$mean, ifelse(unit=="","",paste0(" ", unit)), s$sd, s$n, s$ci95[1], s$ci95[2]))
  }
  prn("Latency (ms)",             summary$latency_ms, "ms")
  prn("MI per bin (BC)",          summary$mi_per_bin_BC, "bits")
  prn("MI rate (BC)",             summary$mi_rate_BC_bits_per_s, "bits/s")
  prn("Processing speed (BC)",    summary$processing_speed_BC_bits_per_s, "bits/s")

  invisible(list(
    trialwise = data.frame(
      trial = seq_len(n_trials),
      latency_ms = latencies,
      mi_per_bin_BC = mi_bin_bc,
      mi_rate_BC_bits_per_s = mi_rate_bc,
      processing_speed_BC_bits_per_s = speeds_bc
    ),
    summary = summary
  ))
}

# ============================================================
# RUN SIMULATION
# ============================================================

set.seed(1)  # optional, for reproducibility
simulation_results <- run_experiment(
    n_trials   = 3,
    n_shuffles = 100,
    bin_ms     = 10,
    verbose    = TRUE
)

