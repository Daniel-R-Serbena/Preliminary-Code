# Required libraries
library(Matrix)
library(ggplot2)

# Create an output folder for logs
if (!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)

# Capture base R session info
si <- sessionInfo()
saveRDS(si, file = "outputs/sessionInfo.rds")
capture.output(print(si), file = "outputs/sessionInfo.txt")

# ============================================================
# PARAMETERS
# ============================================================

# Simulation parameters
dt <- 0.1  # time step (ms)
t_sim <- 1000  # simulation time (ms)
time <- seq(0, t_sim, dt)
n_steps <- length(time)

# Neuron populations (expanded for polysynaptic pathway)
n_sensory <- 5      # number of sensory neurons
n_interneuron <- 5  # number of interneurons (spinal cord processing)
n_motor <- 5         # number of motor neurons
# Number of serial interneuron layers between sensory and motor
n_inter_layers <- 3  # 1 original + 4 more


# LIF neuron parameters (motor + sensory-like principal cells)
lif_params <- list(
    # Membrane
    C_m = 1,      # nF  (≈200 pF)
    g_L = 0.02,      # µS  (≈20 nS) -> tau_m ≈ 10 ms
    E_L = -70,       # mV
    V_th = -52,      # mV
    V_reset = -65,   # mV
    tau_ref = 2.0,   # ms
    
    # Synaptic
    tau_syn = 2.5,   # ms   (fast AMPA-like)
    w_syn = 0.40,    # nA   (scaled so EPSCs can drive spiking with population input)
    delay_syn = 1.0  # ms
)

lif_params$E_exc <- 0      # mV (AMPA/NMDA-like)
lif_params$E_inh <- -70    # mV (GABA_A placeholder, unused unless you add inhibition)
lif_params$use_noise <- TRUE
lif_params$noise_model <- "OU"     # or "white"
lif_params$sigma_I_white <- 0.05   # nA/sqrt(ms)
lif_params$sigma_I_ou    <- 0.08   # nA steady-state SD
lif_params$tau_I_ou      <- 5.0    # ms
lif_params$use_channel_noise <- TRUE
lif_params$sigma_gL_frac    <- 0.03
lif_params$tau_gL           <- 10.0

# Interneuron parameters (slightly faster/leakier)
interneuron_params <- list(
    # Membrane
    C_m = 0.2,      # nF  (≈150 pF)
    g_L = 0.025,     # µS  (≈25 nS) -> tau_m ≈ 6 ms
    E_L = -70,       # mV
    V_th = -50,      # mV  (a bit more excitable)
    V_reset = -67,   # mV
    tau_ref = 2,   # ms
    
    # Synaptic
    tau_syn = 3.0,   # ms
    w_syn = 0.35,    # nA
    delay_syn = 0.8  # ms
)

interneuron_params$E_exc <- 0
interneuron_params$E_inh <- -70

# Stimulus parameters (tonic cutaneous/nociceptive pulse)
stim_params <- list(
    start_time = 100,   # ms
    duration   = 50,    # ms
    intensity  = 50,   # nA  (not 50 nA)
    noise_std  = 0.20   # nA  (baseline sensory variability)
)

# Connectivity (kept plausible for a dense local microcircuit)
connectivity <- list(
    sensory_to_inter = 1,
    inter_to_motor   = 1,
    inter_to_inter   = 1
)

# ISSO AQUI PRECISA ???? Helper to convert your old current-based weight (nA) to conductance (µS)
g_from_w <- function(w_nA, deltaV_mV = 65) w_nA / deltaV_mV  # ≈ at V ~ -65 mV, E_exc = 0

# Replace current-based weight with conductance-based peak (alpha peaks at 1)
lif_params$g_syn_exc   <- g_from_w(lif_params$w_syn)       # ≈ 0.40/65 ≈ 0.00615 µS (6.15 nS)
lif_params$tau_syn_exc <- lif_params$tau_syn               # ms
lif_params$delay_exc   <- lif_params$delay_syn             # ms

interneuron_params$g_syn_exc   <- g_from_w(interneuron_params$w_syn)  # ≈ 0.35/65 ≈ 0.00538 µS
interneuron_params$tau_syn_exc <- interneuron_params$tau_syn
interneuron_params$delay_exc   <- interneuron_params$delay_syn

# ============================================================
# SENSORY STIMULUS GENERATION
# ============================================================

generate_sensory_stimulus <- function(time, stim_params, n_neurons) {
    n_steps <- length(time)
    stimulus <- array(0, dim = c(n_neurons, n_steps))
    
    # Create stimulus window
    stim_start_idx <- which(time >= stim_params$start_time)[1]
    stim_end_idx <- which(time <= stim_params$start_time + stim_params$duration)
    stim_end_idx <- stim_end_idx[length(stim_end_idx)]
    
    for (i in 1:n_neurons) {
        # Add stimulus during stimulus window with spatial pattern
        # Simulate noxious stimulus with varying intensity across sensory field
        spatial_weight <- 0.6 + 0.8 * exp(-((i - n_neurons/2)^2) / (2 * (n_neurons/4)^2))
        stimulus[i, stim_start_idx:stim_end_idx] <- stim_params$intensity * 
            spatial_weight * (0.7 + 0.6 * runif(1))
        
        # Add noise throughout simulation
        stimulus[i, ] <- stimulus[i, ] + rnorm(n_steps, 0, stim_params$noise_std)
    }
    
    return(stimulus)
}

# =========================
# Noise helpers
# =========================

ou_step <- function(x, tau_ms, sigma_ss, dt) {
    if (tau_ms <= 0) return(0)
    x + (-x / tau_ms) * dt + sqrt(2 * (sigma_ss^2) / tau_ms) * sqrt(dt) * rnorm(1)
}
white_I_noise <- function(sigma, dt) {
    if (sigma <= 0) return(0)
    sigma * sqrt(dt) * rnorm(1)
}
# ============================================================
# LIF NEURON MODEL (Conductance-based synapses)
# ============================================================
simulate_lif_neuron_cond <- function(inputs, dt, params) {
    gE <- if (!is.null(inputs$gE)) inputs$gE else rep(0, length(inputs$I_ext))
    gI <- if (!is.null(inputs$gI)) inputs$gI else rep(0, length(gE))
    I_ext <- if (!is.null(inputs$I_ext)) inputs$I_ext else rep(0, length(gE))
    
    n_steps <- max(length(gE), length(gI), length(I_ext))
    V <- numeric(n_steps); spikes <- logical(n_steps)
    V[1] <- params$E_L; t_last_spike <- -Inf
    I_no <- 0; gL_fac <- 0
    
    for (t in 2:n_steps) {
        current_time <- (t - 1) * dt
        if (current_time - t_last_spike > params$tau_ref) {
            
            # leak/channel noise on g_L
            g_L_t <- params$g_L
            if (isTRUE(params$use_noise) && isTRUE(params$use_channel_noise)) {
                gL_fac <- ou_step(gL_fac, params$tau_gL, params$sigma_gL_frac, dt)
                g_L_t  <- params$g_L * pmax(0, 1 + gL_fac)
            }
            
            # membrane current noise (still current-based noise) 
            I_noise <- 0
            if (isTRUE(params$use_noise)) {
                if (identical(params$noise_model, "white")) {
                    I_noise <- white_I_noise(params$sigma_I_white, dt)
                } else if (identical(params$noise_model, "OU")) {
                    I_no    <- ou_step(I_no, params$tau_I_ou, params$sigma_I_ou, dt)
                    I_noise <- I_no
                }
            }
            
            # conductance-based synaptic currents (nA) 
            I_leak <- g_L_t * (params$E_L - V[t-1])
            I_exc  <- gE[t-1] * (params$E_exc - V[t-1])
            I_inh  <- gI[t-1] * (params$E_inh - V[t-1])
            
            I_tot  <- I_leak + I_exc + I_inh + I_ext[t-1] + I_noise
            dV_dt  <- I_tot / params$C_m           # C in nF, currents in nA → mV/ms
            V[t]   <- V[t-1] + dV_dt * dt
            
            if (V[t] >= params$V_th) {
                spikes[t] <- TRUE; V[t] <- params$V_reset; t_last_spike <- current_time
            }
        } else {
            V[t] <- params$V_reset
        }
    }
    list(V = V, spikes = spikes)
}

# ============================================================
# CONDUCTANCE-BASED SYNAPTIC TRANSMISSION
# ============================================================
# Fast alpha-kernel synapses via convolution 
build_alpha_kernel <- function(tau_ms, g_peak, delay_ms, dt, n_tau = 5) {
    klen <- max(1L, ceiling(n_tau * tau_ms / dt))
    tvec <- (0:klen) * dt
    alpha <- (tvec / tau_ms) * exp(1 - tvec / tau_ms)   # peaks at 1
    delay_steps <- max(0L, round(delay_ms / dt))
    c(rep(0, delay_steps), g_peak * alpha)              # include synaptic delay
}

# Convolve 1 spike train (logical/0-1) with kernel; truncate to n_steps
convolve_spike_train <- function(spk, kernel, n_steps) {
    z <- convolve(as.integer(spk), rev(kernel), type = "open")
    as.numeric(z[seq_len(n_steps)])
}

# Convolve every row of a spike matrix [n_pre x n_steps] with the same kernel
convolve_spike_mat <- function(S, kernel) {
    n_steps <- ncol(S)
    t(apply(S, 1L, convolve_spike_train, kernel = kernel, n_steps = n_steps))
}
# ============================================================
# POLYSYNAPTIC NETWORK SIMULATION
# ============================================================

simulate_polysynaptic_reflex <- function() {
    cat("Generating sensory stimulus...\n")
    sensory_stimulus <- generate_sensory_stimulus(time, stim_params, n_sensory)
    
    # Inhomogeneous Poisson sensory spike generator
    poisson_from_rate <- function(rate_hz, dt) {
        p <- 1 - exp(-pmax(0, rate_hz) * (dt / 1000))
        as.logical(rbinom(length(rate_hz), size = 1, prob = p))
    }
    generate_sensory_spikes_inhom <- function(time, stim_params, n_neurons, dt,
                                              base_rate = 5, gain_hz = 25, max_rate = 300) {
        stim_mat <- generate_sensory_stimulus(time, stim_params, n_neurons)
        n_steps <- ncol(stim_mat)
        spikes  <- matrix(FALSE, n_neurons, n_steps)
        for (i in 1:n_neurons) {
            rate <- base_rate + gain_hz * stim_mat[i, ]
            rate <- pmin(max_rate, pmax(0, rate))
            spikes[i, ] <- poisson_from_rate(rate, dt)
        }
        spikes
    }
    
    # Initialize result storage
    sensory_neurons <- list()
    cat("Simulating sensory neurons (inhomogeneous Poisson)…\n")
    sens_spk <- generate_sensory_spikes_inhom(time, stim_params, n_sensory, dt)
    for (i in 1:n_sensory) {
        sensory_neurons[[i]] <- list(V = rep(NA_real_, n_steps), spikes = sens_spk[i, ])
    }
    
    # Precompute kernels for each hop 
    K_SI <- build_alpha_kernel(
        tau_ms   = lif_params$tau_syn_exc,
        g_peak   = lif_params$g_syn_exc,
        delay_ms = lif_params$delay_exc,
        dt       = dt
    )
    K_II <- build_alpha_kernel(
        tau_ms   = interneuron_params$tau_syn_exc,
        g_peak   = interneuron_params$g_syn_exc,
        delay_ms = interneuron_params$delay_exc,
        dt       = dt
    )
    K_IM <- K_II  # same synaptic settings I->M (change if you want different)
    
    # Connectivity as matrices (probabilities -> sparse random)
    # sensory -> first inter layer
    W_SI <- Matrix::rsparsematrix(n_interneuron, n_sensory,
                                  density = connectivity$sensory_to_inter)
    if (length(W_SI@x)) W_SI@x <- runif(length(W_SI@x), 0.7, 1.3)
    
    # inter -> inter (same shape for each serial hop)
    W_II_list <- vector("list", max(0, n_inter_layers - 1L))
    for (L in seq_along(W_II_list)) {
        W_II_list[[L]] <- Matrix::rsparsematrix(n_interneuron, n_interneuron,
                                                density = connectivity$inter_to_inter)
        if (length(W_II_list[[L]]@x)) W_II_list[[L]]@x <- runif(length(W_II_list[[L]]@x), 0.7, 1.3)
    }
    
    # last inter -> motor
    W_IM <- Matrix::rsparsematrix(n_motor, n_interneuron,
                                  density = connectivity$inter_to_motor)
    if (length(W_IM@x)) W_IM@x <- runif(length(W_IM@x), 0.7, 1.3)
    
    # Sensory spikes matrix [n_sensory x n_steps]
    S <- sens_spk  # already (n_sensory x n_steps) logical matrix from your generator
    
    # S -> Inter layer 1 
    G_S <- convolve_spike_mat(S, K_SI)                    # [n_sensory x n_steps], µS
    inter_layers_inputs <- vector("list", n_inter_layers) # store gE per layer
    inter_layers        <- vector("list", n_inter_layers) # store neuron objects
    
    inter_gE <- as.matrix(W_SI %*% G_S)                   # [n_interneuron x n_steps]
    inter_layers_inputs[[1]] <- inter_gE
    
    # Simulate layer 1
    layer_out <- vector("list", n_interneuron)
    for (j in 1:n_interneuron) {
        layer_out[[j]] <- simulate_lif_neuron_cond(
            inputs = list(gE = inter_gE[j, ], gI = rep(0, n_steps), I_ext = rep(0, n_steps)),
            dt = dt, params = interneuron_params
        )
    }
    inter_layers[[1]] <- layer_out
    
    # Serial Inter -> Inter (for layers 2..n_inter_layers)
    if (n_inter_layers >= 2) {
        for (L in 2:n_inter_layers) {
            # presyn spikes matrix from previous layer
            P_prev <- t(vapply(inter_layers[[L - 1]], function(cell) as.integer(cell$spikes), numeric(n_steps)))
            G_prev <- convolve_spike_mat(P_prev, K_II)        # [n_interneuron x n_steps]
            inter_gE <- as.matrix(W_II_list[[L - 1]] %*% G_prev)
            inter_layers_inputs[[L]] <- inter_gE
            
            layer_out <- vector("list", n_interneuron)
            for (j in 1:n_interneuron) {
                layer_out[[j]] <- simulate_lif_neuron_cond(
                    inputs = list(gE = inter_gE[j, ], gI = rep(0, n_steps), I_ext = rep(0, n_steps)),
                    dt = dt, params = interneuron_params
                )
            }
            inter_layers[[L]] <- layer_out
        }
    }
    
    # Last Inter -> Motor 
    P_last <- t(vapply(inter_layers[[n_inter_layers]], function(cell) as.integer(cell$spikes), numeric(n_steps)))
    G_last <- convolve_spike_mat(P_last, K_IM)            # [n_interneuron x n_steps]
    motor_gE_input <- as.matrix(W_IM %*% G_last)          # [n_motor x n_steps]
    
    cat("Simulating motor neurons (conductance-based)…\n")
    motor_neurons <- vector("list", n_motor)
    for (k in 1:n_motor) {
        motor_neurons[[k]] <- simulate_lif_neuron_cond(
            inputs = list(gE = motor_gE_input[k, ], gI = rep(0, n_steps), I_ext = rep(0, n_steps)),
            dt = dt, params = lif_params
        )
    }
    
    return(list(
        sensory              = sensory_neurons,
        interneurons_layers  = inter_layers,
        sensory_stimulus     = sensory_stimulus,
        inter_inputs         = inter_layers_inputs,   # now gE traces (µS)
        motor                = motor_neurons,
        motor_input          = motor_gE_input,        # gE traces (µS)
        time                 = time
    ))
}

# ============================================================
# MOTOR ACTION QUANTIFICATION
# ============================================================

calculate_motor_response <- function(motor_neurons, time) {
    motor_activity <- numeric(length(time))
    
    for (j in 1:length(motor_neurons)) {
        spike_train <- motor_neurons[[j]]$spikes
        motor_activity <- motor_activity + as.numeric(spike_train)
    }
    
# Smooth motor activity (representing muscle activation)
motor_response <- as.numeric(stats::filter(motor_activity, rep(1/7, 7), sides = 2))
motor_response[is.na(motor_response)] <- 0
    return(motor_response)
}

# ============================================================
# LATENCY CALCULATION
# ============================================================

calculate_reflex_latency <- function(stimulus_time, motor_response, time) {
    # Find stimulus onset
    stim_onset <- stim_params$start_time
    
    # Find first significant motor response (threshold crossing)
    baseline <- mean(motor_response[time < stim_onset])
    threshold <- baseline + 2.5 * sd(motor_response[time < stim_onset])
    
    response_idx <- which(motor_response > threshold & time > stim_onset)[1]
    
    if (is.na(response_idx)) {
        return(NA)
    }
    
    latency <- time[response_idx] - stim_onset
    return(latency)
}

# ============================================================
# BIAS CORRECTION
# ============================================================

# KSG kNN MI with shuffle-baseline bias correction (bits)
knn_mi_ksg <- function(x, y, k = 5L, jitter = 1e-8) {
    stopifnot(length(x) == length(y))
    n <- length(x); if (n <= k + 1L) return(NA_real_)
    x <- as.numeric(x); y <- as.numeric(y)
    if (jitter > 0) {
        x <- x + rnorm(n, 0, max(1e-12, sd(x) * jitter))
        y <- y + rnorm(n, 0, max(1e-12, sd(y) * jitter))
    }
    Dx <- abs(outer(x, x, "-")); Dy <- abs(outer(y, y, "-"))
    D  <- pmax(Dx, Dy); diag(D) <- Inf
    eps <- apply(D, 1, function(row) sort(row, partial = k)[k])
    diag(Dx) <- Inf; diag(Dy) <- Inf
    nx <- vapply(seq_len(n), function(i) sum(Dx[i,] < eps[i]), integer(1))
    ny <- vapply(seq_len(n), function(i) sum(Dy[i,] < eps[i]), integer(1))
    I_nats <- digamma(k) + digamma(n) - mean(digamma(nx + 1L) + digamma(ny + 1L))
    max(0, I_nats / log(2))
}

mi_knn_bias_corrected <- function(x, y, k = 5L, n_shuffles = 100L, jitter = 1e-8) {
    mi_raw <- knn_mi_ksg(x, y, k, jitter)   # <-- was mi_knn_ksg_bits
    if (!is.finite(mi_raw) || n_shuffles <= 0L)
        return(list(mi_knn = mi_raw, mi_knn_bc = mi_raw, mi_shuffle_mean = 0))
    mi_shuf <- replicate(n_shuffles, knn_mi_ksg(x, sample(y), k, jitter))
    mu <- mean(mi_shuf[is.finite(mi_shuf)], na.rm = TRUE)
    list(mi_knn = mi_raw, mi_knn_bc = max(0, mi_raw - mu), mi_shuffle_mean = mu)
}

# ============================================================
# INFORMATION CALCULATION
# ============================================================
# MI of Sensory→Motor ONLY (no interneurons used) 
calculate_information_metrics <- function(results,
                                          bin_ms = 5,
                                          k = 3L,
                                          n_shuffles = 100L,
                                          max_lag_ms = 60,
                                          pre_ms = 20,
                                          post_ms = 600) {
    cat("Calculating information metrics (S→M only)…\n")
    
    # Population spike sums
    sensory_pop <- rowSums(sapply(results$sensory, function(x) as.numeric(x$spikes)))
    motor_pop   <- rowSums(sapply(results$motor,   function(x) as.numeric(x$spikes)))
    
    # Basic rates & totals (for summary/prints)
    t_s <- t_sim / 1000
    sensory_rates <- sapply(results$sensory, function(x) sum(x$spikes)) / t_s
    motor_rates   <- sapply(results$motor,   function(x) sum(x$spikes)) / t_s
    total_sensory_spikes <- sum(sensory_pop)
    total_motor_spikes   <- sum(motor_pop)
    
    # Window around stimulus
    win <- results$time >= (stim_params$start_time - pre_ms) &
        results$time <= (stim_params$start_time + post_ms)
    s <- sensory_pop[win]; m <- motor_pop[win]
    
    # Binning
    bin_size <- max(1L, ceiling(bin_ms / dt))
    n_bins_win <- floor(length(s) / bin_size)
    if (n_bins_win < (k + 2L)) {
        warning("Not enough bins for kNN MI; reduce bin_ms, enlarge window, or lower k.")
        return(list(
            sensory_rates = sensory_rates,
            motor_rates   = motor_rates,
            inter_rates   = NA_real_,
            sensory_motor_mi = NA_real_,
            total_pathway_mi = NA_real_,
            n_bins = n_bins_win,
            lags_bins = list(SM = 0L),
            lags_ms   = list(SM = 0),
            sensory_binned = integer(0),
            motor_binned   = integer(0),
            total_sensory_spikes = total_sensory_spikes,
            total_inter_spikes   = NA_integer_,
            total_motor_spikes   = total_motor_spikes
        ))
    }
    
    rng <- seq_len(n_bins_win * bin_size)
    sb <- colSums(matrix(s[rng], nrow = bin_size))
    mb <- colSums(matrix(m[rng], nrow = bin_size))
    
    # Align by measured reflex latency
    motor_response_full <- calculate_motor_response(results$motor, results$time)
    latency_ms <- calculate_reflex_latency(stim_params$start_time, motor_response_full, results$time)
    lag_bins_sm <- if (is.na(latency_ms)) 0L else as.integer(round(latency_ms / bin_ms))
    
    align_pair <- function(x, y, L) {
        if (L > 0) {
            n <- min(length(x), length(y) - L); if (n <= 0) return(list(x = numeric(0), y = numeric(0)))
            list(x = x[seq_len(n)], y = y[(1 + L):(L + n)])
        } else if (L < 0) {
            L <- -L; n <- min(length(x) - L, length(y)); if (n <= 0) return(list(x = numeric(0), y = numeric(0)))
            list(x = x[(1 + L):(L + n)], y = y[seq_len(n)])
        } else list(x = x, y = y)
    }
    ab_sm <- align_pair(sb, mb, lag_bins_sm)
    ok_sm <- length(ab_sm$x) > (k + 1L)
    
    mi_sm <- if (ok_sm) mi_knn_bias_corrected(ab_sm$x, ab_sm$y, k = k, n_shuffles = n_shuffles)$mi_knn_bc else NA_real_
    
    list(
        sensory_rates = sensory_rates,
        inter_rates   = NA_real_,
        motor_rates   = motor_rates,
        sensory_motor_mi = mi_sm,     # <-- the MI you care about
        total_pathway_mi = mi_sm,     # <-- make "total" equal to S→M
        n_bins = length(ab_sm$x),
        lags_bins = list(SM = lag_bins_sm),
        lags_ms   = list(SM = lag_bins_sm * bin_ms),
        sensory_binned = sb,
        motor_binned   = mb,
        total_sensory_spikes = total_sensory_spikes,
        total_inter_spikes   = NA_integer_,
        total_motor_spikes   = total_motor_spikes
    )
}

mi_vs_lag <- function(sim, bin_ms = 10, lags_ms = seq(-80, 120, by = 10), k = 5, n_shuffles = 100) {
    s_pop <- rowSums(sapply(sim$sensory, function(x) as.integer(x$spikes)))
    m_pop <- rowSums(sapply(sim$motor,   function(x) as.integer(x$spikes)))
    
    bin_size <- max(1L, ceiling(bin_ms / dt))
    to_bins <- function(v) {
        nb <- floor(length(v) / bin_size)
        if (nb < 1) return(integer(0))
        rng <- seq_len(nb * bin_size)
        colSums(matrix(v[rng], nrow = bin_size))
    }
    sb <- to_bins(s_pop); mb <- to_bins(m_pop)
    if (length(sb) < (k + 2L) || length(mb) < (k + 2L))
        stop("Not enough bins—increase t_sim or reduce bin_ms.")
    
    lag_bins <- round(lags_ms / bin_ms)
    est <- function(L) {
        if (L > 0) {
            n <- min(length(sb), length(mb) - L); if (n <= 0) return(NA_real_)
            mi_knn_bias_corrected(sb[seq_len(n)], mb[(1+L):(L+n)], k = k, n_shuffles = n_shuffles)$mi_knn_bc
        } else if (L < 0) {
            L <- -L; n <- min(length(sb) - L, length(mb)); if (n <= 0) return(NA_real_)
            mi_knn_bias_corrected(sb[(1+L):(L+n)], mb[seq_len(n)], k = k, n_shuffles = n_shuffles)$mi_knn_bc
        } else {
            mi_knn_bias_corrected(sb, mb, k = k, n_shuffles = n_shuffles)$mi_knn_bc
        }
    }
    mi <- vapply(lag_bins, est, numeric(1))
    data.frame(lag_ms = lags_ms, mi_bits = mi, mi_rate = mi * (1000/bin_ms))
}

plot_mi_vs_lag <- function(tbl) {
    ggplot(tbl, aes(lag_ms, mi_bits)) +
        geom_line() + geom_point(size = 1) +
        labs(x = "Lag (ms)", y = "MI (bits/bin)", title = "Sensory → Motor MI vs lag") +
        theme_bw()
}


# ================================================================
# Information per bin
# ================================================================
# Bin a single neuron's spike train (logical) into counts per bin
bin_spike_train <- function(spikes_logical, bin_size) {
    n <- length(spikes_logical)
    n_bins <- floor(n / bin_size)
    if (n_bins < 1) return(integer(0))
    rng <- seq_len(n_bins * bin_size)
    colSums(matrix(as.integer(spikes_logical[rng]), nrow = bin_size))
}

# Build a (neurons x bins) matrix of counts for a population
binned_counts_matrix <- function(neuron_list, bin_size) {
    stopifnot(length(neuron_list) > 0)
    one <- bin_spike_train(neuron_list[[1]]$spikes, bin_size)
    if (length(one) == 0) return(matrix(integer(0), nrow = length(neuron_list), ncol = 0))
    out <- matrix(0L, nrow = length(neuron_list), ncol = length(one))
    for (i in seq_along(neuron_list)) {
        out[i, ] <- bin_spike_train(neuron_list[[i]]$spikes, bin_size)
    }
    out
}

# ===========================================================
# Pairwise
# ===========================================================
# Compute pairwise KSG MI between every sensory and motor neuron
# lag_bins: shift motor counts forward (positive) or backward (negative) in bins
knn_mi_pairwise_sensory_motor <- function(results, bin_ms = 15, k = 5, lag_bins = 0) {
    bin_size <- max(1L, ceiling(bin_ms / dt))
    
    S <- binned_counts_matrix(results$sensory, bin_size)  # (n_sensory x n_bins)
    M <- binned_counts_matrix(results$motor,    bin_size)  # (n_motor   x n_bins)
    
    if (ncol(S) == 0L || ncol(M) == 0L) {
        warning("Not enough bins for kNN MI; increase t_sim or reduce bin_ms.")
        return(list(MI = matrix(NA_real_, nrow = nrow(S), ncol = nrow(M)),
                    bin_size = bin_size, n_bins = 0L))
    }
    
    # Apply optional lag to motor (aligning with reflex latency in bins)
    align_pair <- function(a, b, lag) {
        if (lag == 0) return(list(ax = a, bx = b))
        if (lag > 0) {
            # motor lagging; drop first 'lag' bins of motor and last 'lag' of sensory
            n <- min(length(a), length(b) - lag)
            if (n <= 0) return(list(ax = numeric(0), bx = numeric(0)))
            list(ax = a[seq_len(n)], bx = b[seq(lag + 1, length.out = n)])
        } else {
            # motor leading; drop first '-lag' bins of sensory and last '-lag' of motor
            lag <- -lag
            n <- min(length(a) - lag, length(b))
            if (n <= 0) return(list(ax = numeric(0), bx = numeric(0)))
            list(ax = a[seq(lag + 1, length.out = n)], bx = b[seq_len(n)])
        }
    }
    
    ns <- nrow(S); nm <- nrow(M)
    MI <- matrix(NA_real_, nrow = ns, ncol = nm)
    for (i in seq_len(ns)) {
        for (j in seq_len(nm)) {
            ab <- align_pair(S[i, ], M[j, ], lag_bins)
            if (length(ab$ax) > k && length(ab$bx) > k) {
                MI[i, j] <- knn_mi_ksg(ab$ax, ab$bx, k = k)
            } else {
                MI[i, j] <- NA_real_
            }
        }
    }
    
    rownames(MI) <- paste0("S", seq_len(ns))
    colnames(MI) <- paste0("M", seq_len(nm))
    list(MI = MI, bin_size = bin_size, n_bins = ncol(S))
}

# ============================================================
# Multi Trials
# ============================================================

# MULTI-TRIAL HELPER
run_mi_over_trials <- function(n_trials = 30, bin_ms = 5, k = 3, pre_ms = 20, post_ms = 600) {
    sb_all <- integer(0); mb_all <- integer(0)
    for (r in seq_len(n_trials)) {
        set.seed(1000 + r)
        res <- simulate_polysynaptic_reflex()
        win <- res$time >= (stim_params$start_time - pre_ms) &
            res$time <= (stim_params$start_time + post_ms)
        s <- rowSums(sapply(res$sensory, function(x) as.integer(x$spikes)))[win]
        m <- rowSums(sapply(res$motor,   function(x) as.integer(x$spikes)))[win]
        bin_size <- max(1L, ceiling(bin_ms / dt))
        rng <- seq_len(floor(length(s) / bin_size) * bin_size)
        sb <- colSums(matrix(s[rng], nrow = bin_size))
        mb <- colSums(matrix(m[rng], nrow = bin_size))
        sb_all <- c(sb_all, sb); mb_all <- c(mb_all, mb)
    }
    mi_knn_bias_corrected(sb_all, mb_all, k = k, n_shuffles = 50L)
}


# ============================================================
# PROCESSING SPEED CALCULATION
# ============================================================

calculate_processing_speed <- function(latency_ms, total_mi, n_bins) {
    if (is.na(latency_ms) || latency_ms <= 0 ||
        is.na(total_mi) || is.na(n_bins) || n_bins <= 0) return(NA_real_)
    
    # Total information transferred through the pathway
    total_info_bits <- total_mi * n_bins
    
    # Processing speed in bits per second
    processing_speed <- total_info_bits / ((latency_ms / 1000)+ 0.75)
    
    return(processing_speed)
}

# ============================================================
# MAIN SIMULATION FUNCTION
# ============================================================

run_polysynaptic_reflex_simulation <- function() {
    cat("Starting polysynaptic reflex simulation...\n")
    cat("Parameters:\n")
    cat(sprintf("  - Sensory neurons: %d\n", n_sensory))
    cat(sprintf("  - Interneurons: %d\n", n_interneuron))
    cat(sprintf("  - Motor neurons: %d\n", n_motor))
    cat(sprintf("  - Simulation time: %d ms\n", t_sim))
    cat(sprintf("  - Time step: %.1f ms\n", dt))
    
    # Run network simulation
    results <- simulate_polysynaptic_reflex()
    lag_tbl <- mi_vs_lag(results, bin_ms = 10, k = 5, n_shuffles = 100)
    
    # Calculate motor response
    motor_response <- calculate_motor_response(results$motor, results$time)
    
    # Calculate latency
    latency <- calculate_reflex_latency(stim_params$start_time, motor_response, results$time)
    
    # Calculate information metrics
    info_metrics <- calculate_information_metrics(results)
    
    # Calculate processing speed
    processing_speed <- calculate_processing_speed(
        latency_ms = latency,
        total_mi = info_metrics$total_pathway_mi,
        n_bins = info_metrics$n_bins
    )
    
    # Print results
    cat("\n", paste(rep("=", 60), collapse = ""), "\n")
    cat("REFLEX SIMULATION RESULTS (S→M MI)\n")
    cat(paste(rep("=", 60), collapse = ""), "\n")
    cat(sprintf("Reflex Latency: %.2f ms\n", ifelse(is.na(latency), 0, latency)))
    cat(sprintf("Sensory→Motor MI (KSG, bias-corrected): %.4f bits\n", info_metrics$sensory_motor_mi))
    cat(sprintf("Total Pathway MI (S→M): %.4f bits\n", info_metrics$total_pathway_mi))
    cat(sprintf("Processing Speed: %.2f bits/second\n", processing_speed))
    cat(sprintf("Total Sensory Spikes: %d\n", info_metrics$total_sensory_spikes))
    cat(sprintf("Total Motor Spikes: %d\n", info_metrics$total_motor_spikes))
    cat(sprintf("Mean Sensory Rate: %.2f Hz\n", mean(info_metrics$sensory_rates)))
    cat(sprintf("Mean Motor Rate: %.2f Hz\n", mean(info_metrics$motor_rates)))
    
    return(list(
        results = results,
        latency = latency,
        processing_speed = processing_speed,
        info_metrics = info_metrics,
        motor_response = motor_response,
        lag_tbl = lag_tbl
    ))
}

# ============================================================
# HELPER FOR LOGS
#=============================================================
write_session_info <- function(outdir = "outputs") {
  if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)
  si <- sessionInfo()
  saveRDS(si, file.path(outdir, "sessionInfo.rds"))
  capture.output(print(si), file = file.path(outdir, "sessionInfo.txt"))
}

# ============================================================
# MULTI-TRIAL PROCESSING SPEED + 95% CI
# ============================================================

run_experiment <- function(n_trials = 3,
			   n_shuffles = 100,
                           bin_ms = 10,
                           verbose = TRUE,
                           seed = NULL) {
on.exit(write_session_info("outputs"), add = TRUE)
    if (!is.null(seed)) set.seed(seed)
    
    # small helper (t-based CI; drops NA/Inf)
    mean_ci <- function(x, conf = 0.95) {
        x <- x[is.finite(x)]
        n <- length(x)
        if (n == 0L) return(list(mean = NA_real_, lower = NA_real_, upper = NA_real_, n = 0L, sd = NA_real_, se = NA_real_))
        if (n == 1L) return(list(mean = mean(x), lower = NA_real_, upper = NA_real_, n = 1L, sd = NA_real_, se = NA_real_))
        m  <- mean(x); s <- sd(x); se <- s / sqrt(n)
        tcrit <- qt(0.975, df = n - 1)  # 95% two-sided
        list(mean = m,
             lower = m - tcrit * se,
             upper = m + tcrit * se,
             n = n, sd = s, se = se)
    }
    
    per_trial <- data.frame(
        trial = seq_len(n_trials),
        latency_ms = NA_real_,
        total_mi_bits = NA_real_,
        n_bins = NA_integer_,
        processing_speed_bps = NA_real_
    )
    
    for (r in seq_len(n_trials)) {
        if (verbose) cat(sprintf("Trial %d/%d…\n", r, n_trials))
        
        # run one simulation
        if (verbose) {
            sim <- simulate_polysynaptic_reflex()
        } else {
            tmp <- capture.output(sim <- simulate_polysynaptic_reflex())
        }
        
        # latency
        motor_resp <- calculate_motor_response(sim$motor, sim$time)
        lat <- calculate_reflex_latency(stim_params$start_time, motor_resp, sim$time)
        
        # information (use your parameters)
        info <- calculate_information_metrics(
            sim,
            bin_ms      = bin_ms,
            n_shuffles  = n_shuffles
            # you can also pass k, pre_ms, post_ms here if you want to tweak them
        )
        
        # processing speed
        bps <- calculate_processing_speed(
            latency_ms = lat,
            total_mi   = info$total_pathway_mi,
            n_bins     = info$n_bins
        )
        
        per_trial$latency_ms[r]          <- lat
        per_trial$total_mi_bits[r]       <- info$total_pathway_mi
        per_trial$n_bins[r]              <- info$n_bins
        per_trial$processing_speed_bps[r] <- bps
    }
    
    ci <- mean_ci(per_trial$processing_speed_bps)
    
    # quick summary line
    if (verbose) {
        cat(sprintf(
            "\nMean processing speed: %.2f bits/s (95%% CI %.2f–%.2f), n=%d\n",
            ci$mean, ci$lower, ci$upper, ci$n
        ))
    }
    
    list(
        per_trial = per_trial,
        processing_speed_ci = ci
    )
}

# ============================================================
# RUN SIMULATION
# ============================================================

set.seed(1)  # optional, for reproducibility
simulation_results <- run_experiment(
    n_trials   = 3,
    n_shuffles = 100,
    bin_ms     = 10,
    verbose    = TRUE
)

# ============================================================
# Figure Creation
# ============================================================

if (!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)

# -- Run ONE detailed simulation for per-trial traces/rasters/latency, etc.
one <- run_polysynaptic_reflex_simulation()  # prints a summary; also returns all needed objects

# -------------------------------
# Fig 2 — Stimulus + activity (single trial)
# Panels: stimulus (top), sensory rasters (mid), motor rasters + population (bottom)
# -------------------------------

# Build tidy dfs
time_vec <- one$results$time

# stimulus matrix -> long
stim_mat <- one$results$sensory_stimulus
stim_df <- data.frame(
  t = rep(time_vec, each = nrow(stim_mat)),
  neuron = rep(seq_len(nrow(stim_mat)), times = length(time_vec)),
  stim = as.vector(stim_mat)
)

# sensory spikes to (t, neuron) points
sens_list <- one$results$sensory
sens_spike_df <- do.call(rbind, lapply(seq_along(sens_list), function(i){
  sp <- which(sens_list[[i]]$spikes)
  if (length(sp) == 0) return(NULL)
  data.frame(t = time_vec[sp], neuron = i)
}))

# motor spikes + population motor_response
motor_list <- one$results$motor
motor_spike_df <- do.call(rbind, lapply(seq_along(motor_list), function(i){
  sp <- which(motor_list[[i]]$spikes)
  if (length(sp) == 0) return(NULL)
  data.frame(t = time_vec[sp], neuron = i)
}))
motor_pop <- calculate_motor_response(one$results$motor, time_vec)

# Plots
p2a <- ggplot(stim_df, aes(t, stim)) +
  geom_line() +
  labs(title = "Stimulus (single trial)", x = "Time (ms)", y = "Intensity (a.u.)") +
  theme_bw()

p2b <- ggplot(sens_spike_df, aes(t, neuron)) +
  geom_point(size = 0.4) +
  labs(title = "Sensory spikes (raster)", x = "Time (ms)", y = "Neuron") +
  theme_bw()

p2c <- ggplot() +
  geom_point(data = motor_spike_df, aes(t, neuron), size = 0.4) +
  labs(title = "Motor spikes (raster)", x = "Time (ms)", y = "Neuron") +
  theme_bw()

p2d <- ggplot(data.frame(t = time_vec, mr = motor_pop), aes(t, mr)) +
  geom_line() +
  labs(title = "Motor population activity (smoothed)", x = "Time (ms)", y = "Spikes/bin (a.u.)") +
  theme_bw()

ggsave("outputs/fig2a_stimulus.png", p2a, width = 6, height = 3, dpi = 300)
ggsave("outputs/fig2b_sensory_raster.png", p2b, width = 6, height = 3, dpi = 300)
ggsave("outputs/fig2c_motor_raster.png", p2c, width = 6, height = 3, dpi = 300)
ggsave("outputs/fig2d_motor_population.png", p2d, width = 6, height = 3, dpi = 300)

# -------------------------------
# Fig 3 — Membrane traces (example neurons) & synaptic drive
# -------------------------------

# pick example neurons (first of each kind)
ex_inter_layer <- 1
ex_inter_neuron <- 1
ex_motor_neuron <- 1

V_inter <- one$results$interneurons_layers[[ex_inter_layer]][[ex_inter_neuron]]$V
V_motor <- one$results$motor[[ex_motor_neuron]]$V

gE_inter <- one$results$inter_inputs[[ex_inter_layer]][ex_inter_neuron, ]
gE_motor <- one$results$motor_input[ex_motor_neuron, ]

p3a <- ggplot(data.frame(t = time_vec, V = V_inter), aes(t, V)) +
  geom_line() +
  labs(title = sprintf("Interneuron V (layer %d, cell %d)", ex_inter_layer, ex_inter_neuron),
       x = "Time (ms)", y = "mV") + theme_bw()

p3b <- ggplot(data.frame(t = time_vec, V = V_motor), aes(t, V)) +
  geom_line() +
  labs(title = sprintf("Motor neuron V (cell %d)", ex_motor_neuron),
       x = "Time (ms)", y = "mV") + theme_bw()

p3c <- ggplot(data.frame(t = time_vec, gE = gE_inter), aes(t, gE)) +
  geom_line() +
  labs(title = "Excitatory conductance into interneuron", x = "Time (ms)", y = "µS") +
  theme_bw()

p3d <- ggplot(data.frame(t = time_vec, gE = gE_motor), aes(t, gE)) +
  geom_line() +
  labs(title = "Excitatory conductance into motor neuron", x = "Time (ms)", y = "µS") +
  theme_bw()

ggsave("outputs/fig3a_inter_V.png", p3a, width = 6, height = 3, dpi = 300)
ggsave("outputs/fig3b_motor_V.png", p3b, width = 6, height = 3, dpi = 300)
ggsave("outputs/fig3c_inter_gE.png", p3c, width = 6, height = 3, dpi = 300)
ggsave("outputs/fig3d_motor_gE.png", p3d, width = 6, height = 3, dpi = 300)

# -------------------------------
# Fig 4 — (Optional) Synaptic kernel & connectivity
# Kernels can be reconstructed from parameters; connectivity matrices require returning W_*.
# -------------------------------

K_SI <- build_alpha_kernel(lif_params$tau_syn_exc, lif_params$g_syn_exc, lif_params$delay_exc, dt)
K_II <- build_alpha_kernel(interneuron_params$tau_syn_exc, interneuron_params$g_syn_exc, interneuron_params$delay_exc, dt)
K_IM <- K_II

kdf <- rbind(
  data.frame(t = (seq_along(K_SI)-1)*dt, g = K_SI, kernel = "S→I"),
  data.frame(t = (seq_along(K_II)-1)*dt, g = K_II, kernel = "I→I"),
  data.frame(t = (seq_along(K_IM)-1)*dt, g = K_IM, kernel = "I→M")
)

p4 <- ggplot(kdf, aes(t, g)) +
  geom_line() +
  facet_wrap(~kernel, scales = "free_y", nrow = 1) +
  labs(title = "Alpha synaptic kernels", x = "Time (ms)", y = "µS") +
  theme_bw()

ggsave("outputs/fig4_kernels.png", p4, width = 8, height = 3, dpi = 300)

# (If you modify simulate_polysynaptic_reflex() to return W_SI, W_II_list, W_IM,
# you can heatmap them similarly.)

# -------------------------------
# Fig 5 — Latency quantification (overlay threshold & onset)
# -------------------------------

mr <- motor_pop
stim_on <- stim_params$start_time
base_idx <- time_vec < stim_on
baseline <- mean(mr[base_idx])
thr <- baseline + 2.5 * sd(mr[base_idx])
resp_idx <- which(mr > thr & time_vec > stim_on)[1]
lat_ms <- if (length(resp_idx)) time_vec[resp_idx] - stim_on else NA_real_

p5 <- ggplot(data.frame(t = time_vec, mr = mr), aes(t, mr)) +
  geom_line() +
  geom_vline(xintercept = stim_on, linetype = 2) +
  geom_hline(yintercept = thr, linetype = 2) +
  { if (!is.na(lat_ms)) geom_vline(xintercept = stim_on + lat_ms, linetype = 3) else NULL } +
  annotate("text", x = stim_on, y = max(mr, na.rm = TRUE), vjust = -0.5, label = "Stimulus") +
  labs(title = sprintf("Latency = %.2f ms", ifelse(is.na(lat_ms), NaN, lat_ms)),
       x = "Time (ms)", y = "Motor pop. (a.u.)") +
  theme_bw()

ggsave("outputs/fig5_latency.png", p5, width = 6, height = 3, dpi = 300)

# -------------------------------
# Fig 6 — Information transfer
# (A) MI vs lag curve (from the table returned in 'one')
# (B) MI per-bin and rate at aligned lag/bin (from calculate_information_metrics)
# -------------------------------

lag_tbl <- one$lag_tbl  # data.frame(lag_ms, mi_bits, mi_rate)
p6a <- ggplot(lag_tbl, aes(lag_ms, mi_bits)) +
  geom_line() + geom_point(size = 1.2) +
  labs(title = "MI vs lag (Sensory → Motor)", x = "Lag (ms)", y = "MI (bits/bin)") +
  theme_bw()

info6 <- one$info_metrics
p6b <- ggplot(data.frame(
  metric = c("MI per bin (BC)", "MI rate (BC)"),
  value  = c(info6$sensory_motor_mi, info6$sensory_motor_mi * (1000/5))  # if bin_ms=5 in info
), aes(metric, value)) +
  geom_bar(stat = "identity") +
  labs(title = "Information metrics (bias-corrected)", x = "", y = "Value") +
  theme_bw()

ggsave("outputs/fig6a_mi_vs_lag.png", p6a, width = 6, height = 3, dpi = 300)
ggsave("outputs/fig6b_mi_summary.png", p6b, width = 5, height = 3, dpi = 300)

# -------------------------------
# Fig 7 — Processing speed (per trial & CI)
# Uses your multi-trial object: simulation_results
# -------------------------------

# If you ran run_experiment() above, you already have simulation_results
# Otherwise, uncomment the next lines to create it here:
# simulation_results <- run_experiment(n_trials = 30, n_shuffles = 100, bin_ms = 10, verbose = FALSE)

pt <- simulation_results$per_trial
ci <- simulation_results$processing_speed_ci

p7a <- ggplot(pt, aes(x = trial, y = processing_speed_bps)) +
  geom_point() +
  geom_hline(yintercept = ci$mean, linetype = 2) +
  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = ci$lower, ymax = ci$upper),
            alpha = 0.1, inherit.aes = FALSE) +
  labs(title = sprintf("Processing speed per trial (mean %.2f, 95%% CI %.2f–%.2f)",
                       ci$mean, ci$lower, ci$upper),
       x = "Trial", y = "Bits/s") +
  theme_bw()

# Optional relationship: latency vs speed
if (all(c("latency_ms","processing_speed_bps") %in% names(pt))) {
  p7b <- ggplot(pt, aes(x = latency_ms, y = processing_speed_bps)) +
    geom_point() +
    labs(title = "Latency vs processing speed", x = "Latency (ms)", y = "Bits/s") +
    theme_bw()
  ggsave("outputs/fig7b_latency_vs_speed.png", p7b, width = 5, height = 4, dpi = 300)
}

ggsave("outputs/fig7a_speed_per_trial.png", p7a, width = 6, height = 4, dpi = 300)

print(p2a); print(p2b); print(p2c); print(p2d)
print(p3a); print(p3b); print(p3c); print(p3d)
print(p4)
print(p5)
print(p6a); print(p6b)
print(p7a)
if (exists("p7b")) print(p7b)
